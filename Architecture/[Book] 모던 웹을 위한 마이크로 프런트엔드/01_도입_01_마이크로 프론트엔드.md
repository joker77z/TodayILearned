# 01. 왜 마이크로 프론트엔드인가?

주요 주제 4가지를 다룬다.

- 웹 어플리케이션 발전
- 마이크로 서비스
- 웹 표준 부상
- 출시 기간 단축

## 웹 어플리케이션의 발전

서버 측 렌더링이 주를 이루다가 동적 데이터를 렌더링하기 위해 클라이언트 영역이 필요해지면서 복잡도가 증가했다. 그러면서 프런트엔드의 영역이 점점 확대되었고, 프론트엔드와 백엔드 분리를 가속화 했다. 즉, 모든 것을 처리하는 거대한 모놀리스 방식이 사라지는 것이었다.   

클라이언트 쪽에서는 SPA로 모든 렌더링을 처리하고, 데이터를 API계층에서 받아오는 형태가 되었는데 이런 분리가 모든 이점을 가져온 것은 아니었다. 적절한 보안 설정, 성능 기준을 세우기가 어려워졌고 이는 배포 관점에서도 문제가 있었다.  

사용자 경험 관점에서도, 부분 페이지를 업데이트 하기 위해 스피너, 스켈레톤 등에 의존한다. 오류를 어떻게 처리할지도 여러 방법 중 올바른 결정을 내리기 위해 시간을 더 할애해야 한다.  

그럼에도 불구하고 대다수 애플리케이션은 프론트와 백을 분할하는 것이 적절하다. 큰 어플리케이션을 효율적으로 개발할 수 있기 때문이다.

<br>

## 마이크로 서비스

마이크로 프런트엔드를 알기에 앞서, 더 오랜 역사를 가진 마이크로 서비스를 알아본다. 더 오래됐기 때문에 해당 기술로 추후 의사 결정을 내릴 때 도움을 받을 수 있다. 백엔드 진영에서는 소규모 서비스를 오케스트레이트 및 마이크로 서비스 아키텍처가 유행했다.  

### SOA와 마이크로 서비스

2000년초, 서비스 지향 아키텍처의 개념이 도입되었다. 많은 요구사항과 제약이 있었다. 모든 것이 이미 정해져 있거나 모범 사례를 반강제로 따라했다. 결국 실패했고, 단시간에 서비스를 구축하는 것은 배제되었다. SOA는 자체 제약뿐 아니라 상호 의존성있는 여러 서비스간 오케스트레이션이 힘들다는 문제가 있었다.

> **오케스트레이션이란?**  
> 프로그래밍에서 오케스트레이션이란 서비스 간 조화롭게 상호작용할 수 있도록 조정 및 조율하는 것을 말한다. 예를 들어 분산시스템에서 각 서비스 간 통신, 작업흐름을 조절하는 것이다. 이를 통해 작업 순서, 우선순위, 병렬처리, 오류 처리 등을 관리하면서 전체 시스템의 효율성 및 안전성을 향상시킨다. 대규모 분산 시스템, 클라우드 컴퓨팅, 컨테이너 오케스트레이션 플랫폼(쿠버네티스) 등에 자주 사용되는 개념이다.

도커가 도입되면서 몇 가지 문제를 해결했다. 도커는 배포가 올바르게 작동하도록 신뢰성있는 방법을 제공한다. 그러면서 마이크로서비스라고 하는 아키텍처 스타일이 탄생한다. 마이크로 서비스는 한 가지만 담당하는 서비스를 구축해야 한다. 대부분 사람들은 **단일 책임 원칙**을 적용할 수 있는 옵션으로 여긴다. 마이크로서비스가 백엔드 구축에 초점이 맞춰져 있기 때문에, 프런트엔드 역시 이런 접근 방식을 따라야 했다. 

### 마이크로 서비스의 장점

마이크로 서비스의 다른 장점들도 있다.

- 단일 서비스와 직접적으로 관련된다.
- 여러 팀이 **독립적으로 작업**할 수 있다.
- 배포 **규모가 작다.**
- 프레임워크, 프로그래밍 언어 **선택의** **자유**
- 초기 **출시 기간이 짧다.**
- 아키텍처 경계가 뚜렷하다.

<br />

### 마이크로 서비스의 단점

- 장애가 발생한 서비스에 종속된 서비스는 이상하게 동작한다. 근본적인 원인을 추적하기 어렵다.
- 프레임워크, 언어의 자유가 단점이 될 수도 있다. 유지보수 할 수 있는 사람을 구하기 쉬워야 한다.
- 버전 관리 어려움

> 그럼에도 불구하고 단점보다 장점에 초점을 맞춰야 한다.

<br >

## 웹 표준의 부상

기존 마이크로 프론트엔드에는 문제점이 있었다. 코드의 격리가 힘들다는 것. 하지만, 프레임워크 등 리소스는 공유해야 한다. 웹 컴포넌트를 통한 격리, 프레임 통신, 웹 워커와 프락시 등을 이용해서 모듈화를 시도했다.

<br />

## 출시 기간 단축

### 조직 적응 시간 단축

최근 평균 근속 기간이 1.5~2.3년이 되면서 큰 코드 베이스의 경우 파악에 6개월이 걸린다고 하면, 약 25%의 시간을 손해본다. 독립적인 저장소로 모듈화를 한 것이 많은 도움이 된다. 새 개발자가 버그 하나를 수정하는데, 작은 저장소에서 수정하면 더 빠르게 디버깅할 수 있다. 커밋 기록도 작아 진입하기도 쉽다.  

단점은 복잡한 버그의 경우 디버깅이 더 힘들 수 있다. 시스템을 완전히 이해하기 위해서 더 높은 전문성이 요구된다. 어떤 코드가 어디에 위치하는지 찾기 어려워진다.  

해결책은 책임을 갖고 기본적인 인프라 전문성을 공유할 수 있는 feature team을 만드는 것이다.

### 여러 개의 팀

여러 저장소로 나눠서 작업할 수 있다. 개별 릴리즈 일정을 가져갈 수 있고 내외부 팀과 작업할 때 가장 큰 이점이 있다. 각 팀이 하나의 백엔드 서비스, 하나의 프런트엔드를 담당하는 팀을 도입할 수 있다. 도메인 기반 설계를 여러 팀과 결합하는 건 인지 부하를 줄이고 명확한 아키텍처 경계를 설정하는 효율적인 방법이 될 수 있다.

### 피처 격리

독립적인 기능일 기능별 일정에 따라 배포할 수 있다는 것을 저자는 가장 좋아한다고 한다. 프로젝트 오너가 새로운 아이디어를 가지고 있을 때 사용자에게는 어떻게 받아들여질지 알 수 없다. 이 때 MVP를 만들어서 빠르게 사용자 피드백을 수집해 볼 수 있다.  

> 잘 설계됐는지 확인하는 좋은 테스트 방법은 해당 모듈을 꺼보는 것이다.

### A/B 테스팅

피처의 두 가지 변형(variant)인 A, B가 존재한다. A는 피처의 현 상태, B는 새로운 방법이다. 모놀리식 프론트엔드에서는 A/B 테스트 기능을 하려면 많은 코드를 수정해야 한다. 수십, 수백곳에 분기가 산재할 수 있다. 마이크로 프론트엔드는 코드 변경 없이 도입할 수 있다.
