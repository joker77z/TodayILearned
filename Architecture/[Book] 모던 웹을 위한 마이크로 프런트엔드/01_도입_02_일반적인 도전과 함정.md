마이크로 프론트엔드를 적용할 때 이슈 5가지를 다뤄보자.

- 성능
- 보안
- 지식 공유
- 신뢰성
- 사용자 경험

## 성능

아마존은 100ms가 지연될 때마다 매출이 1%씩 감소된다고 주장한다. 그만큼 성능이 중요하다.

### 리소스 캐싱

요즘은 다양한 웹사이트가 있다.

- 정적 웹사이트
- AJAX를 이용한 동적 웹사이트
- SPA
- 동적 웹사이트 (서버 측 렌더링)

정적 웹사이트의 경우, 모든 요청을 디스크에서 읽기로 처리하지 않고, 메모리 내 캐시를 사용한다. 서버를 돕고, 브라우저 성능을 향상시킬 수 있다. 단일 애셋으로 모으고 싶을 때도 있을 것이다. 예로 세 개의 마이크로 프런트엔드가 각 JS파일을 만든다면, 한개로 가져가고 싶을 것이다. 이럴 때 기대만큼의 결과를 얻기 힘들다. 이유는 다음과 같다.

- HTTP2는 요청을 스트리밍해, 복수 리소스도 단일 리소스만큼 효율적으로 처리할 수 있다.
- 캐싱이 더 복잡해지고 세밀하지 못하게 되어 캐시 미스가 많아진다.
- 잘못된 스크립트 하나 때문에 집합 내 전체 스크립트 실행이 중단될 수 있다.

결론적으로, 브라우저에서 마이크로 프론트엔드마다 리소스를 소비하는 것을 감수하더라도 전체를 포함한 하나를 사용하는 것보다 나을 때가 많다.

### 번들 크기

번들 크기를 모니터링하고, 작게 유지하는 것이 우수한 성능에 매우 중요하다. 하지만, SPA에서 마이크로 프론트엔드에 대해 하나의 JS파일을 만들기 위해 웹팩, Parcel같은 번들러를 사용한다. 이 JS파일을 분할해야 한다. 웹팩의 경우 코드 분할을 할 수 있고, React에서 lazy함수를 사용해서 한번에 모든 JS파일을 불러오는 것이 아닌 필요한 것만 불러올 수 있다.

```jsx
import * as React from 'react';
import { Switch, Route } from 'react-router-dom';
        
const MyPage = React. lazy(() =› import('./page'));

export const Routes = (
  <React.Suspense fallback={<div>Loading...</div>}>
    <Switch>
      <Route path="/my-page" component={MyPage} />
    </Switch>
  </React.Suspense>
);
```

> webpack-bundle-analyzer로 패키지를 시각화할 수 있다.

### 요청 최적화

모듈은 같거나 유사한 데이터를 매우 빈번하게 요청한다. 캐시를 도입해서 완화할 수 있다. 

### 보안

1. 중앙 사용자 관리 (Centralized User Management): 중앙 사용자 관리는 여러 개별 마이크로 프론트엔드 애플리케이션에서 사용자 인증 및 권한 관리를 중앙 집중화하여 처리하는 방식입니다. 이 방법에서는 사용자 인증 정보와 권한 설정이 중앙 집중화된 사용자 관리 시스템 또는 서비스에서 관리됩니다. 개별 마이크로 프론트엔드 애플리케이션들은 중앙 사용자 관리 시스템과 연동하여 사용자 정보를 검증하고 인증된 사용자에게 액세스 권한을 부여할 수 있습니다. 이렇게 함으로써 사용자 관리를 중앙에서 통제하고 보안 정책을 통일화할 수 있습니다.
2. 개별 사용자 관리 (Decentralized User Management): 개별 사용자 관리는 각각의 마이크로 프론트엔드 애플리케이션이 독립적으로 사용자 인증 및 권한 관리를 처리하는 방식입니다. 이 방법에서는 개별 마이크로 프론트엔드 애플리케이션 내에 사용자 정보를 저장하고 사용자 인증 및 권한 검증을 수행합니다. 각 마이크로 프론트엔드 애플리케이션은 자체적으로 사용자 관리를 처리하므로 독립적으로 보안 정책을 구성하고 적용할 수 있습니다. 그러나 이는 사용자 관리를 중앙에서 통합하여 관리하기 어렵고, 사용자 정보의 일관성을 유지하기 위해 추가적인 노력이 필요할 수 있습니다.

### 신뢰성

수십 개 모듈을 가져올 때 실패할 가능성이 있다. 따라서 느슨한 결합을 도입하고 매우 작은 타임아웃 지정, 중요한 요청은 재시도, 연결 끊김을 감지해 적절하게 처리를 할 수 있도록 한다. 어떤 충돌이 발생하더라도 메인 애플리케이션은 죽지 않도록 한다.

### 사용자 경험

동일한 사용자 경험을 가져갈 수 있도록 한다. 예를 들어 워딩 같은 것!
