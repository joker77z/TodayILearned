# 마이크로 프론트엔드 아키텍처의 종류

다룰 주제는 다음과 같다.

- 마이크로 프론트엔드의 환경
- 정적 vs 동적
- 수평적 구조 vs 수직적 구조
- 백엔드 중심 vs 프론트엔드 중심

## 정적 vs 동적

### 정적

- 장점 : 마이크로 프론트엔드를 구현하는 방법 중 가장 간단한 방법은 여러 패키지로 나눠서 개발 후 하나로 합치는 것이다. 빌드 시점에 모든 정보를 알고 최적화, 검사하기 용이하다.
- 단점 : 마이크로 프론트엔드에서 수정이 발생할 경우 어플리케이션의 변경이 필요하다. 사소한 변경도 재빌드를 해야 한다.  

**<u>천천히 변경되는 웹사이트, 상대적으로 작은 웹 어플리케이션에 주요 사용된다.</u>** Node.js, Express를 사용해 모노레포를 구성하는 솔루션 코드는 다음과 같다.

```bash
# 프로젝트 생성
npm init -y
# Lerna 모노레포로 만든다.
npx lerna init

# 어플리케이션 추가
npx lerna create @aom/app --yes

# 마이크로 프론트엔드 추가
npx lerna create @aom/mife-1 --yes
npx lerna create @aom/mife-2 --yes

# 의존성 등록
npx lerna add @aom/mife-1 --scope @aom/app
npx lerna add express pug
```

경로에 따라 기본 사항을 등록할 수 있다.

```js
const express = require("express");
const app = express();
const port = process.env.PORT || 1234;
app.set("view engine", "pug");
app.get("/", (_, res) => {
  res.render ("index", { title: "Sample", message: "Index" });
});
// 마이크로프런트엔드구성하기
require("@aom/mife-1")(app); 
require("@aom/mife-2")(app);
app.listen(port, () => {
  console. log('Running at ${port).');
});
```

다른 페이지들은 마이크로 프론트엔드로부터 통합된다.

```js
const path = require("path");
const express = require("express");

module.exports = setupMicrofrontend1;

function setupMicrofrontend1 (app) {
  app.use("/mf1", express.static(path. join(__dirname, "..", "public")));
  
  app.get("/mf1", (_, res) => {
    const page = require.resolve('../views/index.pug');
    res.render(page, {title: "Sample", mesage: "MF1"});
}
```

정적 접근 방식의 장점은 대체적으로 보일러플레이트 코드를 사용해 새로운 마이크로 프론트엔드를 생성한 후 사용할 수 있다는 것이다. 긴 인프라 구성이나 통합하기 위한 미세 조정은없다. 마이크로 프론트엔드를 변경하면 전체를 다시 빌드해야 한다.

### 동적

동적 접근 방식은 구현하기 훨씬 더 어렵다. 해결해야 할 3가지 과제가 있기 때문.

- 소스에 마이크로 프론트엔드를 게시하는 방법
- 소스를 업데이트하는 방법
- 어플리케이션을 소스에 연결하는 방법  

동적 접근 방식은 많은 자유를 준다. 메인 어플리케이션을 방해하지 않고 계속 수정할 수 있다. 하지만, 인프라 수준에서 복잡성을 더한다. 모듈 페더레이션을 사용해 해결할 수 있다.

> **웹팩의 모듈 페더레이션이란**  
>
> 모듈 페더레이션은 여러 개의 분리된 빌드가 하나의 앱을 구성할 수 있는 Webpack 5의 새로운 기능입니다. 하나의 앱이 다른 빌드에 있는 코드를 동적으로 실행시킬 수 있는 기술입니다.
>
> 모듈 페더레이션은 마이크로 프론트엔드 개발에 적합한 솔루션입니다. 마이크로 프론트엔드는 더 작은 독립적인 앱으로 구성된 웹 애플리케이션입니다. 모듈 페더레이션을 사용하면 이러한 마이크로 프론트엔드를 **별도로 개발하고 배포할 수 있으며 하나의 앱으로 결합할 수도 있습니다.**
>
> 모듈 페더레이션은 또한 기존 앱을 모듈화하는 데 사용할 수 있는 도구입니다. 기존 앱이 너무 커서 유지 관리가 어렵다면 모듈 페더레이션을 사용하여 더 작은 독립적인 모듈로 분리할 수 있습니다. 그런 다음 이러한 모듈을 별도로 개발하고 배포할 수 있으며 하나의 앱으로 결합할 수도 있습니다.
>
> 모듈 페더레이션을 사용하면 애플리케이션 또는 모듈 간의 경계를 넘어서 모듈을 공유하고 사용할 수 있습니다. 이는 코드의 중복을 줄이고 개발자들이 독립적으로 모듈을 개발하고 배포할 수 있도록 지원합니다. 또한, 각 모듈이 독립적으로 업데이트되므로 애플리케이션의 전체적인 개발과 배포 속도가 향상됩니다.

<br />

---

## 수평적 구성 vs 수직적 구성

- 수평적 구조
  - 기능을 기반으로 분리, 페이지별로 만들 수 있다
  - 팀이 동시에 작업하는 더 작은 모듈
  - 팀이 앱 전체 구조를 이해해야 함
  - 관리하기 쉬운 방법을 고려할 때 선택

- 수직적 구조
  - 영역(기술)으로 분리, 하나의 페이지에 많은 마이크로 프론트엔드로 만들 수 있다
  - 특정 영역만 집중하면 되서 단순
  - 하지만, 다른 앱의 부분들과 상호 작용하는 방식을 이해해야 함. 더 복잡할 수 있다.
  - 확장을 고려할 때 선택

<br />

---

## 백엔드 중심 vs 프론트엔드 중심

- 백엔드 중심
  - 모놀리식과 성능이 거의 동일하다.
  - 규모 변경성과 신뢰성을 유지하기 위해 복잡한 인프라가 필요하다.