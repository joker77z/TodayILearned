## 객체란?

- JS는 객체 기반 언어이며, JS의 거의 모든 것이며 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.

- 객체는 0개 이상 프로퍼티로 구성된 집합이며, 프로퍼티는 키, 값으로 구성된다.
- 모든 값은 프로퍼티 값이 될 수 있으며, 함수도 될 수 있다. 이런 함수를 메서드라 부른다.
- 객체는 프로퍼티와 메서드로 구성된다.

<br />

## 객체 리터럴로 객체 생성

C++, Java같은 <u>클래스 기반</u> 객체 지향 언어는 클래스를 사전에 정의하고 필요할 때 new 연산자와 함께 생성자를 호출해서 **인스턴스를 생성하는 방식으로 객체를 생성한다.**

- **객체지향 프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념**이다.
- **클래스**는 인스턴스를 생성하기 위한 템플릿이다.

> **인스턴스란?**  
> 메모리에 저장된 실체

JS는 <u>프로토타입 기반 객체지향 언어</u>로 클래스 기반 객체지향 언어와 달리 **다양한 객체 생성방법**을 지원한다.

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- ES6의 클래스

> 객체 리터럴의 중괄호는 코드 블록을 의미하지 않는데 주의하자! 객체 리터럴은 값으로 평가되는 표현식이다. 따라서 세미콜론을 뒤에 붙인다.

<br />

## 프로퍼티

프로퍼티 키에는 모든 문자열을 사용 할 수 있고 값에는 JS에서 사용할 수 있는 모든 값을 사용할 수 있다. 식별자 네이밍 규칙을 따르면 따음표를 생략할 수 있다.

- 숫자 리터럴을 프로퍼티 키로 사용 시, 따음표는 붙지 않지만 내부적으로 문자열로 변환된다.
- 키를 중복 선언하면 에러없이 덮어쓴다.

<br />

## 메서드

JS에서 프로퍼티 값으로 함수를 사용할 수 있다. 그것이 메서드다.

```js
const circle = {
    radius: 5,
    getDiameter() {
        return this.radius*2;
    }
}

circle.getDiameter() // 10

const circle2 = {
    radius: 5,
    getDiameter: function() {
        return this.radius*2;
    }
}

circle2.getDiameter() // 10
```

<br />

## 프로퍼티 접근

- 마침표 표기법 : 마침표는 프로퍼티 키가 **식별자 네이밍 규칙을 준수**했을 때 사용할 수 있다.
- 대괄호 표기법 : 모든 경우에 사용 가능하며 따음표로 감싸야 하지만, 숫자는 제외한다. 암묵적으로 감싸서 평가된다.

> 객체에 없는 프로퍼티에 접근하면 에러가 발생하지 않고 undefined가 나온다.

<br />

## 프로퍼티 삭제

delete로 삭제할 수 있지만, 존재할 수 없는 프로퍼티를 삭제하려고 했을 때 에러가 발생하지 않으니 유의해야 한다. 

<br />

## 객체 확장 기능

값으로 평가되는 표현식으로 키를 동적 생성할 수 있다. 이 때 대괄호로 묶어야 한다. 이를 계산된 프로퍼티 이름이라 한다.

```js
const prefix = 'prop';
let i = 0;
const obj = {};

obj[`${prefix}-${i++}`] = i;
obj[`${prefix}-${i++}`] = i;
obj[`${prefix}-${i++}`] = i;
console.log(obj); // {prop-0: 1, prop-1: 2, prop-2: 3}
```

ES6에서는 객체 내부에서도 키를 동적생성할 수 있다.

```js
const prefix = 'prop';
let i = 0;

const obj = {
    [`${prefix}-${i++}`]: i,
    [`${prefix}-${i++}`]: i,
    [`${prefix}-${i++}`]: i,
}
console.log(obj); // {prop-0: 1, prop-1: 2, prop-2: 3}
```

