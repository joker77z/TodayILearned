## 함수

```js
function add(x, y) { // 인자(매개변수, parameter)를 받는다.
	return x+y;
}

add(2, 5); // 인수(argument)를 전달한다.
```

<br />

## 함수를 사용하는 이유

- 반복적으로 수행해야 하는 코드를 계속 쓰는 것이 아니라, 함수를 만들어 놓으면 몇 번이든 호출하면서 재사용 할 수 있다.
- 함수는 코드의 중복을 억제하고, 재사용성을 높여서 유지보수 편의성을 높이고 실수를 줄여서 코드의 신뢰성을 올릴 수 있다.
- 적절한 함수 이름으로 내부 코드를 이해하지 않고도 역할을 파악할 수 있게 한다.

<br/>

## 함수 리터럴

함수는 **객체 타입의 값**이다. 따라서, 숫자 값을 리터럴로 생성하거나 객체를 객체 리터럴로 생성하는 것처럼 함수도 함수 리터럴로 생성할 수 있다. 함수 리터럴은 function 키워드, 함수 이름, 매개 변수 목록, 함수 몸체로 구성된다.

```js
// 변수에 함수 리터럴을 할당해보자.
var f = function add(x, y) {
	return x+y;
}
```

함수 리터럴의 구성요소를 function키워드를 제외하고 정리해보자.

- 함수 이름 : 함수 이름은 식별자다. 식별자 네이밍 규칙을 준수해야 하고, 몸체 내에서만 참조할 수 있다. 이름이 있냐없냐에 따라 기명/무명함수라 부른다.
- 매개변수 목록 : 순서에 의미를 갖고, 함수 몸체 내에서 변수와 동일하게 사용되어, 식별자 네이밍 규칙을 지켜야 한다.
- 함수 몸체 : 함수 호출에 의해 실행된다.

> 함수는 객체지만, 일반 객체와 다르다. 함수는 호출 가능하다. 그리고, 함수 객체만의 고유한 프로퍼티를 갖는다. 이는 다른 언어와 비교되는 중요한 특징이다. 18장 "함수와 일급 객체"에서 더 자세히 알아본다.

<br />

## 함수 정의

함수는 4가지 방식으로 만들 수 있다. 우리가 흔히 아는 함수 선언문인 `function 함수명`을 이용하는 방법, 함수 표현식, Function 생성자 함수, 화살표 함수(ES6)가 있다. 함수가 평가되면 <u>식별자가 암묵적으로 생성되고 함수 객체가 할당된다.</u> 

> 변수는 '선언'했지만, 함수는 '정의'한다고 했다. ECMAScript 사양에서도 declaration과 definition을 다르게 사용하고 있다.

<br />

## 함수 선언문

함수 선언문은 표현식이 아닌 문이다. <u>**표현식이 아닌 문은 변수에 할당할 수 없다.**</u> **<u>하지만, 다음 예제를 보면 변수에 할당이 정상적으로 되는 것처럼 보인다.</u>**

```js
var add = function add(x, y) {
  return x + y;
};
```

이유는 무엇일까? js엔진에 의해 평가될 때 코드 문맥에 따라서 함수 리터럴이 표현식으로 해석 될 수도, 아닐수도 있기 때문이다. 위 경우에는 표현식으로 해석된다. 아래 예제를 보자.

```js
function foo() {
  console.log('foo');
}
foo(); // foo

(function bar() { console.log('bar') }; )
bar(); // ReferenceError: bar is not defined
```

foo 함수 리터럴은 선언문으로 해석된다. bar 함수 리터럴은 그룹 연산자 내에 있어서 평가문으로 해석된다. 그룹 연산자의 피연산자는 값으로 평가될 수 있는 표현식이어야 된다.

> 그런데, foo는 호출할 수 있고 bar는 호출할 수 없다. 함수 리터럴은 함수 내부에서만 함수 이름으로 호출할 수 있어야 하는데 말이다. 이는 함수 객체를 생성하는 것은 동일하지만 호출하는 것에 차이가 있기 때문이다.  
> foo()에서 호출할 수 있었던 이유는 js엔진이 암묵적으로 식별자를 생성했기 때문이다. 함수 객체를 가리켜야 호출할 수 있기 때문에 참조할 수 있는 식별자를 생성하는 것이다. 식별자를 만들고 그 식별자에 할당한다.  
> **즉, 함수 선언문으로 해석되면 js엔진이 함수 이름과 동일한 식별자를 만들어준다. 이는 함수는 함수 이름으로 호출하는게 아니라 함수 객체를 가리키는 식별자로 호출하는 것을 뜻한다.**

따라서 foo는 호출 할 수 있지만, bar는 함수 리터럴 표현식으로 생성되었기 때문에 호출할 수 없다. 따라서, 함수 내에서만 함수 이름으로 호출할 수 있다.  

의사 코드로 살펴보면 다음과 같다.

```js
// var 식별자 = function 함수 이름(x, y) {}
var add = function add(x, y){
  return x+y;
}

// console.log(식별자(2, 3))
console.log(add(2, 3));
```

<br />

### 함수 표현식

앞서 말했듯, 함수는 객체 타입의 값이다.

- 변수에 할당
- 객체 프로퍼티에 할당
- 배열의 요소

위 3가지를 할 수 있다. 이렇게 **값의 성질을 갖는 객체**를 **일급 객체**라 한다. **일급 객체는 값처럼 자유롭게 사용 가능하다.** 함수 리터럴의 함수 이름은 생략 가능하다고 했다. 이렇게 익명 함수를 함수 표현식이라고 한다.

```js
var add = function (x, y) {
  return x + y;
}
```

<br />

### 함수 생성 시점과 함수 호이스팅

함수 선언문은 이전에 호출할 수 있지만, 함수 표현문은 호출할 수 없다. 이는 함수 생성 시점이 다르기 때문이다. 함수 선언문은 런타임 이전에 js엔진에 의해 먼저 해석된다. 하지만, 함수 표현식의 변수 할당문은 런타임 시에 평가되어 함수 객체가 할당된다. 

> 이런 함수 호이스팅으로 인해 함수를 호출하기 전에 반드시 선언해야 한다는 규칙을 무시하게 된다. 그래서, JSON을 창안한 더글라스 크락포드는 함수 선언문 대신 함수 표현식을 사용할 것을 권한다.

<br />

### Function 생성자 함수

Function 생성자 함수로 함수를 생성할 수는 있지만 일반적이지 않고 바람직하지도 않다. 함수 선언문, 함수 표현식과 다르게 동작한다.

Function 생성자 함수로 생성한 함수는 클로저 패턴도 사용할 수 없다.

```js
const add = (function() {
  const a = 10;
  return function (x, y) {
    return x + y + a;
  }
})();

add(2, 3) // 15
```

```js
const add = (function() {
  const a = 10;
  return new Function('x', 'y', 'return x+y+a;');
})();

add(2, 3) // ReferenceError: a is not defined
```

<br />

### 화살표 함수

ES6에서 도입되었으며, function 키워드 대신 화살표를 사용해 좀 더 간결하게 표현한다. 항상 익명함수다. 내부 동작 또한 간략화되어있다. 생성자 함수로 생성할 수 없으며, this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며, arguments 객체를 생성하지 않는다.

<br />

## 함수 호출

### 매개변수와 인수

- 매개변수는 함수를 정의할 때 선언하며, 함소 몸체 내에서 변수와 동일하게 취급된다. 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고, 일반 변수와 동일하게 undefined로 초기화된 이후에 인수가 할당된다.
- 전달하는 인수의 개수가 적을 시 전달되지 않은 매개변수는 undefiend이며, 에러가 발생하지 않는다.
- 반대로 전달하는 인수의 개수가 초과일 경우에는 무시되는 것처럼 보인다. 실제로는 모든 인수는 arguments객체 프로퍼티로 보관된다.
  ```js
  function add(x, y) {
    console.log(arguments);
    return x + y;
  }

  console.log(add(2, 3, 5));
  // Arguments(3) [2, 3, 5, callee: ƒ, Symbol(Symbol.iterator): ƒ]
  ```
  > arguments 객체는 몇 개의 인자를 정할지 알 수 없는 가변 인자 함수에 사용된다.


<br />

결론적으로 자바스크립트는 함수를 정의할 때 적잘한 인수가 전달되었는지 확인할 필요가 있다.  
확인하기 위해서는 아래와 같이 확인할 수 있다.
```js
function add(x, y) {
    if(arguments.length !== 2) {
        throw new Error('전달된 인수의 개수가 인자 개수와 일치하지 않습니다.')
    }
    
    if(typeof x !== 'number' || typeof y !== 'number') {
        throw new Error('인자가 숫자가 아닙니다.')
    }
    return x+y;
}
```

그런데, 타입 에러는 실제로 코드가 동작하는 런타임 환경에서 함수가 호출될 때 발생한다는 것이다. 이런 에러를 사전에 방지하기 위해서는 타입스크립트를 사용해서 컴파일 시점에 발견하는 방법이 있다.
<br />

### 매개변수의 최대 개수
함수는 한 가지 일만 해야 하고, 가급적 작게 만들어야 한다. <b>3개 이상을 넘기지 않는 것을 권장하고, 그 이상의 매개변수가 필요하다면 객체를 전달받는 것이 유리하다.</b> 이 때 주의할 점은 함수 내에서 객체를 변경하게 되면 부수효과가 발생한다는 것.
> 매개변수가 적어야 하는 이유는, 매개변수가 많으면 순서에 신경을 써야 하기 때문이다. 또는 이 함수가 여러가지 일을 하고 있다는 반증이 되기도 한다. 휴먼 에러를 발생시킬 확률도 높이고 가독성, 유지보수성이 더 나빠진다.

<br />

### 반환문
함수 내 반환문(return)은 return만 쓰거나 생략할 경우 암묵적으로 undefined를 반환한다.

<br />

## 참조에 의한 전달과 외부 상태의 변경
원시 값은 복사되어 전달되고, 객체는 참조 값이 복사되어 전달된다.
```js
function test(cnt, person) {
    cnt += 10;
    person.age += 10;
}

let cnt = 10
let person = {
    name: 'parktaejoon',
    age: 31
}

console.log(cnt) // 10
console.log(person.age) // 41
```
> 객체가 이렇게 동작하기 때문에, 개발자가 예측하지 못하는 상황이 일어날 수 있다. 이를 방지 하기 위해 깊은 복사로 부수효과를 없앨 수 있다. 이렇게 외부 상태를 변경하지도 않고 의존하지도 않으려 해서 부수효과를 억제하고 프로그램 안정성을 높이는 것을 함수형 프로그래밍이라 한다.

<br />

### 재귀함수
> 반복문을 사용하는 것보다 재귀 함수를 사용하는 편이 더 직관적으로 이해하기 쉬울 때만 한정적으로 사용하는 것이 바람직하다.

<br />

### 중첩 함수
ES6 이전에는 코드 최상위 or 함수 내부에서만 함수 정의를 할 수 있었지만, ES6 이후부터는 if문이나 for문 등 코드 블록 내에서도 정의할 수 있다.
> 단, 호이스팅으로 인해 혼란을 유발할 수 있어서 if나 for문 등 코드 블럭에서 함수 선언문으로 정의를 하는 것은 바람직하지 않다.

<br />

### 콜백 함수
함수의 매개변수로 함수를 전달시킬 수 있는데 이를 콜백 함수라고 한다. 콜백 함수를 전달받은 함수를 고차 함수라고 한다
> 콜백 함수가 특정 함수 내부에서만 동작한다면, 익명 함수로 곧바로 고차 함수에게 전달하는 것이 일반적이다. 만약, 여러번 호출되거나 다른 곳에서도 사용한다면 별도의 함수를 만드는 것이 좋다. 왜냐면 고차함수가 호출될 때마다 새로운 함수가 생성될 것이기 때문이다. 대표적인 콜백함수로 window.addEventListener, setTimeout, 배열 고차함수인 map같은 것들이 있다.

<br />

### 순수 함수, 비순수 함수
순수 함수는 동일한 인수가 전달되면 항상 같은 값을 반환한다. 어떤 외부 상태에도 의존하지 않고 매개변수에만 의존한다. 또한 외부 상태를 바꾸지도 않는다.
> 비순수 함수는 외부 상태(예를 들어 변수)를 참조하고 직접 변경하기 때문에 나중에 코드가 길어지게되면 어디서 변경되었는지 추적하기 어려워지기 때문에 지양해야 한다.