## 함수

```js
function add(x, y) { // 인자(매개변수, parameter)를 받는다.
	return x+y;
}

add(2, 5); // 인수(argument)를 전달한다.
```

<br />

## 함수를 사용하는 이유

- 반복적으로 수행해야 하는 코드를 계속 쓰는 것이 아니라, 함수를 만들어 놓으면 몇 번이든 호출하면서 재사용 할 수 있다.
- 함수는 코드의 중복을 억제하고, 재사용성을 높여서 유지보수 편의성을 높이고 실수를 줄여서 코드의 신뢰성을 올릴 수 있다.
- 적절한 함수 이름으로 내부 코드를 이해하지 않고도 역할을 파악할 수 있게 한다.

<br/>

## 함수 리터럴

함수는 **객체 타입의 값**이다. 따라서, 숫자 값을 리터럴로 생성하거나 객체를 객체 리터럴로 생성하는 것처럼 함수도 함수 리터럴로 생성할 수 있다. 함수 리터럴은 function 키워드, 함수 이름, 매개 변수 목록, 함수 몸체로 구성된다.

```js
// 변수에 함수 리터럴을 할당해보자.
var f = function add(x, y) {
	return x+y;
}
```

함수 리터럴의 구성요소를 function키워드를 제외하고 정리해보자.

- 함수 이름 : 함수 이름은 식별자다. 식별자 네이밍 규칙을 준수해야 하고, 몸체 내에서만 참조할 수 있다. 이름이 있냐없냐에 따라 기명/무명함수라 부른다.
- 매개변수 목록 : 순서에 의미를 갖고, 함수 몸체 내에서 변수와 동일하게 사용되어, 식별자 네이밍 규칙을 지켜야 한다.
- 함수 몸체 : 함수 호출에 의해 실행된다.

> 함수는 객체지만, 일반 객체와 다르다. 함수는 호출 가능하다. 그리고, 함수 객체만의 고유한 프로퍼티를 갖는다. 이는 다른 언어와 비교되는 중요한 특징이다. 18장 "함수와 일급 객체"에서 더 자세히 알아본다.

<br />

## 함수 정의

함수는 4가지 방식으로 만들 수 있다. 우리가 흔히 아는 함수 선언문인 `function 함수명`을 이용하는 방법, 함수 표현식, Function 생성자 함수, 화살표 함수(ES6)가 있다. 함수가 평가되면 <u>식별자가 암묵적으로 생성되고 함수 객체가 할당된다.</u> 

> 변수는 '선언'했지만, 함수는 '정의'한다고 했다. ECMAScript 사양에서도 declaration과 definition을 다르게 사용하고 있다.

<br />

## 함수 선언문

함수 선언문은 표현식이 아닌 문이다. <u>**표현식이 아닌 문은 변수에 할당할 수 없다.**</u> **<u>하지만, 다음 예제를 보면 변수에 할당이 정상적으로 되는 것처럼 보인다.</u>**

```js
var add = function add(x, y) {
  return x + y;
};
```

이유는 무엇일까? js엔진에 의해 평가될 때 코드 문맥에 따라서 함수 리터럴이 표현식으로 해석 될 수도, 아닐수도 있기 때문이다. 위 경우에는 표현식으로 해석된다. 아래 예제를 보자.

```js
function foo() {
  console.log('foo');
}
foo(); // foo

(function bar() { console.log('bar') }; )
bar(); // ReferenceError: bar is not defined
```

foo 함수 리터럴은 선언문으로 해석된다. bar 함수 리터럴은 그룹 연산자 내에 있어서 평가문으로 해석된다. 그룹 연산자의 피연산자는 값으로 평가될 수 있는 표현식이어야 된다.

> 그런데, foo는 호출할 수 있고 bar는 호출할 수 없다. 함수 리터럴은 함수 내부에서만 함수 이름으로 호출할 수 있어야 하는데 말이다. 이는 함수 객체를 생성하는 것은 동일하지만 호출하는 것에 차이가 있기 때문이다.  
> foo()에서 호출할 수 있었던 이유는 js엔진이 암묵적으로 식별자를 생성했기 때문이다. 함수 객체를 가리켜야 호출할 수 있기 때문에 참조할 수 있는 식별자를 생성하는 것이다. 식별자를 만들고 그 식별자에 할당한다.  
> **즉, 함수 선언문으로 해석되면 js엔진이 함수 이름과 동일한 식별자를 만들어준다. 이는 함수는 함수 이름으로 호출하는게 아니라 함수 객체를 가리키는 식별자로 호출하는 것을 뜻한다.**

따라서 foo는 호출 할 수 있지만, bar는 함수 리터럴 표현식으로 생성되었기 때문에 호출할 수 없다. 따라서, 함수 내에서만 함수 이름으로 호출할 수 있다.  

의사 코드로 살펴보면 다음과 같다.

```js
// var 식별자 = function 함수 이름(x, y) {}
var add = function add(x, y){
  return x+y;
}

// console.log(식별자(2, 3))
console.log(add(2, 3));
```

<br />

### 함수 표현식

앞서 말했듯, 함수는 객체 타입의 값이다.

- 변수에 할당
- 객체 프로퍼티에 할당
- 배열의 요소

위 3가지를 할 수 있다. 이렇게 **값의 성질을 갖는 객체**를 **일급 객체**라 한다. **일급 객체는 값처럼 자유롭게 사용 가능하다.** 함수 리터럴의 함수 이름은 생략 가능하다고 했다. 이렇게 익명 함수를 함수 표현식이라고 한다.

```js
var add = function (x, y) {
  return x + y;
}
```

<br />

### 함수 생성 시점과 함수 호이스팅

함수 선언문은 이전에 호출할 수 있지만, 함수 표현문은 호출할 수 없다. 이는 함수 생성 시점이 다르기 때문이다. 함수 선언문은 런타임 이전에 js엔진에 의해 먼저 해석된다. 하지만, 함수 표현식의 변수 할당문은 런타임 시에 평가되어 함수 객체가 할당된다. 

> 이런 함수 호이스팅으로 인해 함수를 호출하기 전에 반드시 선언해야 한다는 규칙을 무시하게 된다. 그래서, JSON을 창안한 더글라스 크락포드는 함수 선언문 대신 함수 표현식을 사용할 것을 권한다.

<br />

### Function 생성자 함수



<br />
