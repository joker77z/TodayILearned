# 리액트 에센셜

## Sever Components

### Thinking in Server Components

React Server Components는 목적에 따라 유연하게 렌더링할 위치를 클라이언트 or 서버로 선택할 수 있다.

![Thinking in Server Components](../../images/ServerComponents.png)

페이지를 작은 컴포넌트로 분할할 경우, 대부분 컴포넌트는 상호작용이 불필요한 컴포넌트고 서버에서 렌더링될 수 있다. 작은 상호작용 UI의 경우 클라이언트 컴포넌트에서 뿌릴 수 있다. 이는 Next.js의 서버 우선 접근 방식과 일치한다.

### Why Server Components? (서버 컴포넌트를 선택해야 하는 이유)

초기 HTML을 서버에서 렌더링하고 클라이언트 측에서 런타임을 비동기적으로 로드해서 점진적으로 향상시키고 상호 작용을 추가할 수 있다.

- 데이터를 가져오는 행위를 DB와 가깝게 서버로 이동할 수 있다.

- 서버에서 필요한 모듈을 import해서 사용할 수 있게 되어 클라이언트 JS 번들 크기를 줄일 수 있다. 성능 향상도 기대할 수 있다.

- 초기 페이지 로드 속도가 빨라진다.

- 추가적인 JS는 상호작용이 사용되는 경우에만 추가된다.


## Client Components

클라이언트 측 상호작용을 추가할 수 있다. 서버에서 미리 렌더링되고 클라이언트에서 hydrate된다.

### The "use client" directive

The `"use client"` directive는 서버 컴포넌트와 클라이언트 컴포넌트의 경계를 정의하는 컨벤션이다.

![Use Client Directive and Network Boundary](../../images/use-client-directive.png)

`"use client"`는 서버 전용 코드와 클라이언트 코드 사이에 위치한다. 서버에서 클라이언트 부분까지 경계를 정의하기 위해 import하는 파일 가장 위에 배치한다. 한번만 `"use client"`를 선언하면 하위 다른 모듈들은 클라이언트 번들 일부가 된다.

<br />

## When to use Server and Client Components?

서버 컴포넌트와 클라이언트 컴포넌트 간의 결정을 간소화하기 위해 클라이언트 컴포넌트에 대한 사용 사례가 있을 때까지 서버 컴포넌트(앱 디렉토리의 기본값)를 사용하는 것이 좋다.

| What do you need to do?                                      | Server Component | Client Component |
| ------------------------------------------------------------ | ---------------- | ---------------- |
| Fetch data.                                                  | O                | X                |
| Access backend resources (directly)                          | O                | X                |
| Keep sensitive information on the server (access tokens, API keys, etc) | O                | X                |
| Keep large dependencies on the server / Reduce client-side JavaScript | O                | X                |
| Add interactivity and event listeners (`onClick()`, `onChange()`, etc) | X                | O                |
| Use State and Lifecycle Effects (`useState()`, `useReducer()`, `useEffect()`, etc) | X                | O                |
| Use browser-only APIs                                        | X                | O                |
| Use custom hooks that depend on state, effects, or browser-only APIs | X                | O                |
| Use [React Class components](https://react.dev/reference/react/Component) | X                | O                |

<br />

## Pattern

### leaf로 클라이언트 컴포넌트를 이동

성능을 향상시키기 위해 클라이언트 컴포넌트를 가능하면 leaf로 이동시키는 것이 좋다. 예를 들어 정적요소와 함께 있는 검색바를 생각해보자. 전체 레이아웃을 Client 컴포넌트로 만드는 것보다 서버 컴포넌트를 유지하면서 인터렉티브한 컴포넌트를 뺀다.

`app/layout.tsx`

```tsx
// SearchBar is a Client Component
import SearchBar from './searchbar';
// Logo is a Server Component
import Logo from './logo';
 
// Layout is a Server Component by default
export default function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  );
}
```

<br />

### 클라이언트 및 서버 컴포넌트 구성

서버 및 클라이언트 컴포넌트는 동일한 트리에서 결합할 수 있다. 백그라운드에서 React는 다음과 같이 렌더링 처리한다.

- 클라이언트로 보내기 전 서버 컴포넌트를 렌더링한다. 이 단계에서 클라이언트 컴포넌트는 건너뛴다.
- 클라이언트에서 React는 서버 컴포넌트의 렌더링된 결과에다가 컴포넌트 및 slot을 렌더링해서 병합한다.
  - 만약, 서버 컴포넌트가 클라이언트 컴포넌트 내에 중첩되어 있다면 클라이언트 컴포넌트 내에 옳바르게 배치된다.

<br />

### 클라이언트 컴포넌트 내부에 서버 컴포넌트 중첩

렌더링 흐름을 고려할 때, 서버 컴포넌트를 클라이언트 컴포넌트로 가져오는 데는 추가 서버 왕복이 필요하므로 제한이 있다.

#### 지원되지 않는 패턴 : 클라이언트 컴포넌트로 서버 컴포넌트 가져오기

이 패턴은 지원되지 않는다. 서버 컴포넌트를 클라이언트 컴포넌트로 가져올 수 없다.

`app/example-client-component.tsx`

````tsx
'use client';
 
// This pattern will **not** work!
// You cannot import a Server Component into a Client Component.
import ExampleServerComponent from './example-server-component';
 
export default function ExampleClientComponent({
  children,
}: {
  children: React.ReactNode;
}) {
  const [count, setCount] = useState(0);
 
  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>
 
      <ExampleServerComponent />
    </>
  );
}
````

#### 권장패턴 : 서버 컴포넌트를 클라이언트 컴포넌트에 props로 전달

대신에, 클라이언트 컴포넌트에 서버 컴포넌트를 위해 props를 사용할 수 있다.

서버 컴포넌트는 서버에서 렌더링되고, 클라이언트 컴포넌트가 클라이언트에서 렌더링될 때 hole에 서버 컴포넌트의 렌더링된 결과가 채워진다.

일반적인 패턴은 hole을 만들기 위해 `children` prop을 사용하는 것이다. 위 ExampleClientComponent를 리팩터링해보자.

`app/example-client-component.tsx`

```tsx
'use client';
 
import { useState } from 'react';
 
export default function ExampleClientComponent({
  children,
}: {
  children: React.ReactNode;
}) {
  const [count, setCount] = useState(0);
 
  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>
 
      {children}
    </>
  );
}
```

지금은, ExampleClientComponent에서 children이 무엇인지 알지 못한다. 상위 서버 컴포넌트에서는 ExampleClientComponent와 ExampleServerComponent 다 가져올 수 있고, ExampleClientComponent 자식으로 ExampleServerComponent를 가져오는 식이 된다.

`app/page.tsx`

```tsx
// This pattern works:
// You can pass a Server Component as a child or prop of a
// Client Component.
import ExampleClientComponent from './example-client-component';
import ExampleServerComponent from './example-server-component';
 
// Pages in Next.js are Server Components by default
export default function Page() {
  return (
    <ExampleClientComponent>
      <ExampleServerComponent />
    </ExampleClientComponent>
  );
}
```

이런 접근방식으로, ExampleClientComponent와 ExampleServerComponent 렌더링이 분리되고 클라이언트 컴포넌트보다 먼저, 서버에서 독립적으로 서버 컴포넌트는 렌더링 될 수 있다.

> **Good To Know**  
>
> - 이 패턴은 이미 children prop과 함께 **<u>레이아웃 및 페이지</u>**에 적용되었다.  그래서 너는 추가적인 wrapper 컴포넌트를 만들필요가 없다.











> **원문**  
> [React 에센셜 원문](https://nextjs.org/docs/getting-started/react-essentials)

<br />