타입스크립트가 값을 추론하는 두 가지 핵심 개념

- 유니언(union): 값에 허용된 타입을 **두 개 이상 확장**하는 것
- 내로잉(narrowing): 값에 허용된 타입을 **한 개로 좁히는 것**

유니언, 내로잉은 다른 프로그래밍 언어에서는 불가능하지만, **ts에서는 가능한 '코드 정보에 입각한 추론'을 해내는 강력한 개념이다.**

## 유니언 타입

```ts
let mathematician = Math.random() > 0.5
  ? undefined
  : "Mark";
```

`mathematician`변수는 잠재적인 타입이기는 하지만 undefined, string 중 하나 일 수 있다. 이런걸 **유니언**이라고 한다. **유니언 타입은 정확한 타입은 모르지만 두 개 이상 중 하나라는 것을 알고 있는 경우에 코드를 처리하는 개념이다.** 유니언 타입은 수직선 연산자(|)로 나타낸다. 마우스를 올려보면 `let mathematician: string | undefined`로 타입이 표시된다.

<br />

### 유니언 타입 선언

변수에 초기값이 있어도 잠재적으로 변할 것임을 명시적으로 알려줄 수 있다.

```ts
let thinker: string | null = null;

if(Math.random() > 0.5) {
  thinker = 'langer'; // ok
}
```

thinker변수는 null로 초기화되었지만, 추후 string이 될 수 있음을 명시적으로 `string | null` 타입 애너테이션으로 제공했다.

> 유니언 타입 선언의 순서는 중요하지 않다.

<br />

### 유니언 속성

유니언 타입일 때 유니언으로 선언한 타입들의 멤버 속성에만 접근할 수 있다.

```ts
let physicist = Math.random() > 0.5
  ? "Marie"
  : 84;

physicist.toString(); // ok
physicist.toUpperCase(); 
// Error: Property 'toUpperCase' does not exist on type 'string | number'
//   Property 'toUpperCase' does not exist on type 'number'.
```

`physicist`변수는 `string | number`인 유니언 타입으로 주어졌다. 두 타입에서 다 사용 가능한 toString메서드는 사용 가능하지만, `toUpperCase()`같은 메서드는 string에서만 사용할 수 있어서 에러가 발생한다. 반대로 소수점 하위 개수를 정하는 `toFixed()`메서드는 number에서만 사용할 수 있어서 사용 시 에러가 발생한다.

> 만약, 위와 같은 예제에서 string에서만 혹은 number에서만 사용할 수 있는 메서드를 사용하려면, **내로잉**을 해야 한다. 타입을 구체적으로 정해주는 작업을 해야 한다.

<br />

## 내로잉

내로잉은 이전에 유추된 것보다 더 구체적인 타입임을 유추하는 것이다. 타입을 좁히는데 사용할 수 있는 논리적 검사를 `타입가드`라고 한다.  

타입스크립트가 타입을 좁히는데 사용하는 타입 가드 두 가지를 알아보자.

### 값 할당을 통한 내로잉

초기에는 유니언 타입이었지만 추후 초기값이 주어질 때 값 할당 내로잉이 작동했다. 

```ts
let amdin : number | string;
admin = 'taejoon';
admin.toUpperCase(); // OK
admin.toFixed();
// Error: Property 'toFixed' does not exist on type 'string'.
```

아래 예제는 바로 초기값을 할당하면서 타입을 좁혔다.

```ts
let admin : number | string = 'taejoon';
admin.toUpperCase(); // OK
admin.toFixed();
// Error: Property 'toFixed' does not exist on type 'string'.
```

<br />

### 조건 검사를 통한 내로잉

일반적으로 타입스크립트에서는 if문을 쓸 때 변수의 값이 원하는 값인지 확인하고 해당 타입에 맞는 메서드를 내부에서 호출한다.

```ts
let lotto = Math.random() > 0.1 ? 'lucky!' : 'fail';
if(lotto === 'lucky!') {
  lotto.upperCase(); // Ok
}

lotto.toUpperCase();
// Error: Property 'toUpperCase' does not exist on type 'string | number'.
//   Property 'toUpperCase' does not exist on type 'number'.
```

<br />



### typeof 검사를 통한 내로잉

typeof 연산자를 이용해서 값을 좁힐 수도 있다.

```ts
let lotto = Math.random() > 0.1 ? 'lucky!' : 'fail';
if(typeof lotto === 'string') {
  lotto.upperCase(); // Ok
}
```

삼항 연산자 문도 잘 작동한다.

```ts
typeof lotto === 'string'
  ? lotto.toUpperCase() // ok
  : lotto.toFixed(); // ok
```

> 어떤 방법으로 하든 typeof 검사는 타입을 좁히기 위해 자주 사용하는 실용적인 방법이다. ts는 뒤에서 볼 더 많은 내로잉 형태를 이해한다.

<br />

## 리터럴 타입

리터럴 타입은





